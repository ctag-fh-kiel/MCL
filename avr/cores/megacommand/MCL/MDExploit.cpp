/* Copyright 2018, Justin Mammarella jmamma@gmail.com */
#include "MCL.h"
#include "MDExploit.h"
uint8_t last_md_track = 0;
void MDExploit::setup() {}
void MDExploit::setup_global(uint8_t global_num) {
  /** Original position of the global inside the MD (0 to 7). **/
  if (global_num == 0) {
    global_one.origPosition = 6;
  } else {
    global_one.origPosition = 7;
  }
  /** Stores the audio output for each track. **/

  for (uint8_t track_n = 0; track_n < 16; track_n++) {
    if (IS_BIT_SET32(mcl_cfg.cues, track_n)) {
      global_one.drumRouting[track_n] = 5;
    } else {
      global_one.drumRouting[track_n] = 6;
    }
  }

  // baseChannel
  // -- 0
  // 1-4 1
  // 5-8 2
  // 9-12 3
  // 13-16 4

  /** The MIDI base channel of the MachineDrum. **/
  if (global_num == 0) {
    global_one.baseChannel = 3;
  } else {
    global_one.baseChannel = 9;
  }

  global_one.extendedMode = true;
  if (MidiClock.mode == MidiClock.EXTERNAL_MIDI) {
    global_one.clockIn = false;
    global_one.clockOut = true;
  } else {
    global_one.clockIn = true;
    global_one.clockOut = false;
  }
  global_one.transportIn = true;
  // some bug
  global_one.transportOut = true;
  global_one.localOn = true;
  if ((MidiClock.tempo > 30) && (MidiClock.tempo < 300)) {
    global_one.tempo = MidiClock.tempo * 24;
  } else {
    global_one.tempo = 125 * 24;
  }
  global_one.drumLeft = 16;
  global_one.drumRight = 16;
  global_one.programChange = 2;
}
void MDExploit::send_globals() {
  //  if (rec_global) {
  DEBUG_PRINT_FN();
  ElektronDataToSysexEncoder encoder(&MidiUart);
  ElektronDataToSysexEncoder encoder2(&MidiUart);
  setup_global(0);
  in_sysex = 1;
  global_one.toSysex(encoder);
  setup_global(1);
  global_one.toSysex(encoder2);
  in_sysex = 0;
  //  }
}

void MDExploit::switch_global(uint8_t global_page) {
  DEBUG_PRINT_FN();
  uint8_t data[] = {0x56, (uint8_t)global_page & 0x7F};
  in_sysex = 1;
  MD.sendSysex(data, countof(data));
  in_sysex = 0;
}
bool MDExploit::on() {
  // DEBUG_PRINTLN("Exploit on");
  //  DEBUG_PRINTLN(slowclock);

  // in_sysex = 1;
  if (!MD.connected) {
    return;
  }
  note_interface.note_proceed = false;
  note_interface.init_notes();

  if (state) {
    start_clock = slowclock;
    return false;
  }
  md_exploit_callbacks.setup_callbacks();
  md_exploit_midievents.setup_callbacks();
  state = true;
  // last_md_track = MD.getCurrentTrack(CALLBACK_TIMEOUT);
  // if (MidiClock.state == 2) {
  last_md_track = MD.currentTrack;
  MD.setStatus(0x22, 15);
  //}
  // MD.getBlockingGlobal(0);

  /*if (MidiClock.state == 2) {

    div16th_last = MidiClock.div16th_counter;
    noteproceed = 0;
    }
    else {
    noteproceed = 1;
    }
  */
  note_interface.notecount = 0;
  //   global_new.baseChannel = 9;
  //  ElektronDataToSysexEncoder encoder(&MidiUart);
  //   global_new.toSysex(encoder);
  //    MD.setTempo(MidiClock.tempo);

  int flag = 0;

  //     if ((MidiClock.state == 2) && (MidiClock.mode ==
  //     MidiClock.EXTERNAL_UART2)) {
  if ((MidiClock.state == 2) && (MidiClock.mode == MidiClock.EXTERNAL_UART2)) {
    flag = 1;
  }

  if (flag == 1) {
    MidiUart.m_putc_immediate(MIDI_STOP);
  }
  //   }

  MD.global.baseChannel = 3;

  switch_global(6);

  //     if ((MidiClock.state == 2) &&  (MidiClock.mode ==
  //     MidiClock.EXTERNAL_UART2)) {
  if (flag == 1) {
    MidiUart.m_putc_immediate(MIDI_CONTINUE);
  }
  //    }
  //  MD.getBlockingStatus(MD_CURRENT_GLOBAL_SLOT_REQUEST,200);
  start_clock = slowclock;
  return true;
  // note_interface.state = true;
  // in_sysex = 0;
}
bool MDExploit::off() {
  if (!MD.connected) {
    return;
  }
  note_interface.note_proceed = false;
  // DEBUG_PRINTLN("Exploit off");
  //     DEBUG_PRINTLN(slowclock);
  // in_sysex = 1;
  if (!state) {
    return false;
  }
  md_exploit_callbacks.remove_callbacks();
  md_exploit_midievents.remove_callbacks();

  note_interface.state = false;

  //
  //  global_new.tempo = MidiClock.tempo;
  //   global_new.baseChannel = 3;
  //    ElektronDataToSysexEncoder encoder(&MidiUart);
  //   global_new.toSysex(encoder);
  int flag = 0;
  if ((MidiClock.state == 2) && (MidiClock.mode == MidiClock.EXTERNAL_UART2)) {
    flag = 1;
  }
  if (flag == 1) {
    MidiUart.m_putc_immediate(MIDI_STOP);
  }
  //   }
  MD.global.baseChannel = 9;

  switch_global(7);
  //    if ((MidiClock.state == 2) && (MidiClock.mode ==
  //    MidiClock.EXTERNAL_UART2)) {
  if (flag == 1) {
    MidiUart.m_putc_immediate(MIDI_CONTINUE);
  }
  //   }
  //  if (MidiClock.state == 2) {
  MD.setStatus(0x22, last_md_track);
  //  }
  state = false;
  return true;
  // in_sysex = 0;
}

void MDExploitMidiEvents::setup_callbacks() {
  if (state) {
    return;
  }
  Midi.addOnNoteOnCallback(
      this, (midi_callback_ptr_t)&MDExploitMidiEvents::onNoteOnCallback_Midi);
  Midi.addOnNoteOffCallback(
      this, (midi_callback_ptr_t)&MDExploitMidiEvents::onNoteOffCallback_Midi);
  Midi.addOnControlChangeCallback(
      this,
      (midi_callback_ptr_t)&MDExploitMidiEvents::onControlChangeCallback_Midi);

  state = true;
}

void MDExploitMidiEvents::remove_callbacks() {

  if (!state) {
    return;
  }
  Midi.removeOnNoteOnCallback(
      this, (midi_callback_ptr_t)&MDExploitMidiEvents::onNoteOnCallback_Midi);
  Midi.removeOnNoteOffCallback(
      this, (midi_callback_ptr_t)&MDExploitMidiEvents::onNoteOffCallback_Midi);
  Midi.removeOnControlChangeCallback(
      this,
      (midi_callback_ptr_t)&MDExploitMidiEvents::onControlChangeCallback_Midi);

  state = false;
}
void MDExploitCallbacks::setup_callbacks() {
  if (state) {
    return;
  }
  MidiClock.addOnMidiStartCallback(
      this,
      (midi_clock_callback_ptr_t)&MDExploitCallbacks::onMidiStartCallback);
  MidiClock.addOnMidiContinueCallback(
      this,
      (midi_clock_callback_ptr_t)&MDExploitCallbacks::onMidiStartCallback);

  state = true;
};
void MDExploitCallbacks::remove_callbacks() {
  if (!state) {
    return;
  }
  MidiClock.removeOnMidiStartCallback(
      this,
      (midi_clock_callback_ptr_t)&MDExploitCallbacks::onMidiStartCallback);
  MidiClock.removeOnMidiContinueCallback(
      this,
      (midi_clock_callback_ptr_t)&MDExploitCallbacks::onMidiStartCallback);

  state = false;
};

uint8_t MDExploitMidiEvents::note_to_trig(uint8_t note_num) {

  uint8_t trig_num = 0;
  for (uint8_t i = 0; i < sizeof(MD.global.drumMapping); i++) {
    if (note_num == MD.global.drumMapping[i]) {
      trig_num = i;
    }
  }
  return trig_num;
}
void MDExploitMidiEvents::onNoteOnCallback_Midi(uint8_t *msg) {
  if (!note_interface.note_proceed) {
    uint16_t current_clock = slowclock;

    if (clock_diff(md_exploit.start_clock, current_clock) >
        EXPLOIT_DELAY_TIME) {
      note_interface.note_proceed = true;
    }
  }

  if (note_interface.note_proceed) {
    if ((msg[0] == 153)) {
      note_interface.note_on_event(note_to_trig(msg[1]), UART1_PORT);
    }
  }
}
void MDExploitMidiEvents::onNoteOffCallback_Midi(uint8_t *msg) {
  if (note_interface.note_proceed) {
    if ((msg[0] == 153)) {
      note_interface.note_off_event(note_to_trig(msg[1]), UART1_PORT);
    }
  }
}

void MDExploitMidiEvents::onControlChangeCallback_Midi(uint8_t *msg) {
  DEBUG_PRINTLN("CC received");
  DEBUG_PRINTLN(msg[1]);
  DEBUG_PRINTLN(msg[2]);
  if (msg[2] < 120) {
    if (md_exploit.off()) {
      GUI.setPage(&grid_page);
    }
  }
}

void MDExploitCallbacks::onMidiStartCallback() {

  //     if ((curpage == S_PAGE) || (curpage == W_PAGE) || (curpage == CUE_PAGE)
  //     || (curpage == MIXER_PAGE)) {
  md_exploit.start_clock = slowclock;
  note_interface.note_proceed = false;
  // }
  mcl_actions_callbacks.start_clock32th = 0;
}

MDExploit md_exploit;
